import tkinter as tk
from tkinter import filedialog
from PIL import Image, ImageTk
import cv2
import numpy as np

# Global variables to store image and contours
image = None
contours = []
selected_contour = []
drawn_contour = []

# Global variable to store the scale (mm per pixel)
scale = None

def detect_and_display_contours():
    global image, contours, scale
    
    # Read the image file
    image_path = file_path_label.cget("text")
    image = cv2.imread(image_path)
    
    # Convert the image to grayscale
    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    
    # Detect edges using Canny
    edges = cv2.Canny(gray, 100, 200)
    
    # Find contours
    contours, _ = cv2.findContours(edges, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    
    # Draw contours on the image with different colors
    for i, contour in enumerate(contours):
        color = (0, 255, 0)  # Default color is green
        cv2.drawContours(image, [contour], -1, color, 2)
    
    # Convert image to PIL format
    image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)
    pil_image = Image.fromarray(image)
    
    # Convert PIL image to Tkinter format
    tk_image = ImageTk.PhotoImage(pil_image)
    
    # Display the image with contours
    image_label.config(image=tk_image)
    image_label.image = tk_image
    
    # Calculate scale (mm per pixel)
    calculate_scale()

    # Enable the "Select Contour" button
    select_contour_button.config(state="normal")
    
    # Enable the "Draw Contour" button
    draw_contour_button.config(state="normal")

def calculate_scale():
    global scale
    
    # Here you would determine the scale based on known reference points in the image
    # For example, if you have a ruler in the image, you can measure its length in pixels
    # and its length in millimeters, then calculate the scale
    # For simplicity, let's assume a scale of 1 mm per pixel
    scale = 1.0

def calculate_pixels_to_mm(pixels):
    global scale
    
    if scale is None:
        return None  # Scale not calculated yet
    else:
        return pixels * scale

def select_contour():
    global selected_contour
    
    # Prompt user to click on the contour
    print("Click on a contour to select it.")
    
    # Clear previously selected contour
    selected_contour = []
    
    # Bind mouse click event to function
    image_label.bind("<Button-1>", on_click)

def on_click(event):
    global contours, selected_contour, image
    
    # Get the coordinates of the click
    x, y = event.x, event.y
    
    # Check if the click is inside any contour
    for contour in contours:
        if cv2.pointPolygonTest(contour, (x, y), False) >= 0:
            # Store the selected contour
            selected_contour = contour
            
            # Highlight the selected contour in blue
            highlighted_image = np.copy(image)
            cv2.drawContours(highlighted_image, [contour], -1, (255, 0, 0), 2)  # Blue color
            
            # Convert image to PIL format
            pil_image = Image.fromarray(cv2.cvtColor(highlighted_image, cv2.COLOR_BGR2RGB))
            
            # Convert PIL image to Tkinter format
            tk_image = ImageTk.PhotoImage(pil_image)
            
            # Display the image with highlighted contour
            image_label.config(image=tk_image)
            image_label.image = tk_image
            
            # Calculate the number of pixels inside the contour
            pixels_inside = cv2.contourArea(contour)
            
            # Convert pixels to millimeters
            mm_inside = calculate_pixels_to_mm(pixels_inside)
            
            # Update the status label
            if mm_inside is not None:
                status_label.config(text=f"Pixels inside contour: {pixels_inside}, Millimeters inside contour: {mm_inside:.2f} mm")
            else:
                status_label.config(text="Scale not calculated.")
            break
    else:
        # No contour selected
        status_label.config(text="No contour selected.")

def draw_contour():
    global drawn_contour
    
    # Clear previously drawn contour
    drawn_contour = []
    
    # Prompt user to draw the contour
    print("Click to draw the contour. Click 'End Drawing' when done.")
    
    # Bind mouse click event to function
    image_label.bind("<Button-1>", draw_point)

def draw_point(event):
    global drawn_contour, image
    
    # Get the coordinates of the click
    x, y = event.x, event.y
    
    # Draw a point on the image
    cv2.circle(image, (x, y), 2, (0, 0, 255), -1)
    
    # Add the point to the drawn contour
    drawn_contour.append([x, y])

    # Update the image with the drawn contour
    update_image_with_drawn_contour(drawn_contour)

    # Check if drawn contour forms a closed shape
    if len(drawn_contour) > 2 and np.allclose(drawn_contour[0], drawn_contour[-1], atol=5):
        end_draw()

def end_draw():
    global drawn_contour, image
    
    # Convert the drawn contour to numpy array format
    drawn_contour = np.array(drawn_contour)
    
    # Draw the contour on the image
    cv2.drawContours(image, [drawn_contour], -1, (0, 0, 255), 2)
    
    # Update the image with the drawn contour
    update_image_with_drawn_contour(drawn_contour)
    
    # Calculate the number of pixels inside the drawn contour
    pixels_inside = cv2.contourArea(drawn_contour)
    
    # Convert pixels to millimeters
    mm_inside = calculate_pixels_to_mm(pixels_inside)
    
    # Update the status label with the measurement
    if mm_inside is not None:
        status_label.config(text=f"Pixels inside drawn contour: {pixels_inside}, Millimeters inside drawn contour: {mm_inside:.2f} mm")
    else:
        status_label.config(text="Scale not calculated.")

def update_image_with_drawn_contour(drawn_contour):
    global image
    
    # Create a copy of the original image
    drawn_image = np.copy(image)
    
    # Draw the contour on the copied image
    if len(drawn_contour) > 1:
        for i in range(1, len(drawn_contour)):
            cv2.line(drawn_image, tuple(drawn_contour[i-1]), tuple(drawn_contour[i]), (0, 0, 255), 2)
    
    # Convert image to PIL format
    drawn_image = cv2.cvtColor(drawn_image, cv2.COLOR_BGR2RGB)
    pil_image = Image.fromarray(drawn_image)
    
    # Convert PIL image to Tkinter format
    tk_image = ImageTk.PhotoImage(pil_image)
    
    # Display the image with drawn contour
    image_label.config(image=tk_image)
    image_label.image = tk_image

def open_image():
    # Open a file dialog to select an image from the specified directory
    file_path = filedialog.askopenfilename(initialdir="C:/Users/Racem/Desktop/contours", title="Select Image File", filetypes=(("Image files", "*.jpg;*.jpeg;*.png"), ("All files", "*.*")))
    
    # Check if a file is selected
    if file_path:
        # Update the label with the file path
        file_path_label.config(text=file_path)
        
        # Open the image using PIL
        global image
        image = Image.open(file_path)
        
        # Convert image to Tkinter format
        tk_image = ImageTk.PhotoImage(image)
        
        # Display the image in a new window
        image_label.config(image=tk_image)
        image_label.image = tk_image
        
        # Enable the "Show Contours" button
        show_contours_button.config(state="normal")
    else:
        print("No image selected.")

# Create the main Tkinter window
root = tk.Tk()
root.title("Pixel Count")

# Label to display the file path
file_path_label = tk.Label(root, text="")
file_path_label.pack(pady=5)

# Label to display the image
image_label = tk.Label(root)
image_label.pack(pady=5)

# Button to open the image
open_button = tk.Button(root, text="Open Image", command=open_image)
open_button.pack(side="left", padx=5, pady=5)

# Button to show contours
show_contours_button = tk.Button(root, text="Show Contours", command=detect_and_display_contours, state="disabled")
show_contours_button.pack(side="left", padx=5, pady=5)

# Button to select a contour
select_contour_button = tk.Button(root, text="Select Contour", command=select_contour, state="disabled")
select_contour_button.pack(side="left", padx=5, pady=5)

# Button to draw a contour
draw_contour_button = tk.Button(root, text="Draw Contour", command=draw_contour, state="disabled")
draw_contour_button.pack(side="left", padx=5, pady=5)

# Label to display status
status_label = tk.Label(root, text="")
status_label.pack(pady=5)

# Run the Tkinter event loop
root.mainloop()
